use crate::ast::{Operand,Recipe,SourceFile,Quantity};
use regex::Regex;

grammar;

pub SourceFile: SourceFile = {
    <Recipe+> => SourceFile{
        recipes: <>,
    }
}
Recipe: Recipe = { "<" <t:Title?> <p:Preamble?> <r:Operand> <c:Comment?> ">" => Recipe{
        title: t,
        preamble: p,
        root: r,
        comment: c,
    },
}

Title: String = {
    "**" <Sentence> => <>
}
Preamble: String = {
    "##" <Sentence> => <>
}
Comment: String = {
    "#*" <Sentence> => <>
}


Operand: Operand = {
    <Ingredient> => <>,
    <o:Operand> <s:UnaryOperator> => Operand::UnaryOp(Box::new(o), s),
    <l:Operand> <r:Operand> <s:BinaryOperator> => Operand::BinaryOp(Box::new(l), Box::new(r), s),
}

UnaryOperator: String = {
    "=" <Sentence> => <>
}

BinaryOperator: String = {
    "#" <Sentence> => <>
}

Ingredient: Operand = {
    "*" <d:"^"?> <m:Measure?> <n:Sentence> => {
        if let Some(m) = m {
            Operand::Ingredient{
                derived: d.is_some(),
                quantity: m.0,
                unit: m.1,
                name: n,
            }
        } else {
            Operand::Ingredient{
                derived: d.is_some(),
                quantity: vec![],
                unit: None,
                name: n,
            }
        }
    }
}

Measure: (Vec<Quantity>, Option<String>) = {
    <q:Quantity*> <u:Sentence?> ":" => {
        (q,u)
    }
}

Quantity: Quantity = {
    number => Quantity::Number(<>.trim().to_string()),
    fraction => Quantity::Fraction(<>.trim().to_string()),
}

Sentence: String = {
    sentence => {
        let re = Regex::new(r"\r?\n\s+").unwrap();
        re.replace_all(<>.trim(), " ").to_string()
    }
}

match {
    "<",
    ">",
    "=",
    "#",
    ":",
    "*",
    "^",
    "**",
    "#*",
    "##",
} else {
    r"\d+/\d+" => fraction,
} else {
    r"\d+(\.\d+)?" => number,
} else {
    r"[^^~\s\d\./<>=#:*][^^<>=#:*]*" => sentence,
}
